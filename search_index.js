var documenterSearchIndex = {"docs":
[{"location":"#LinA.jl-Documentation","page":"LinA.jl Documentation","title":"LinA.jl Documentation","text":"","category":"section"},{"location":"","page":"LinA.jl Documentation","title":"LinA.jl Documentation","text":"Linearize","category":"page"},{"location":"#LinA.Linearize","page":"LinA.jl Documentation","title":"LinA.Linearize","text":"Linearize(expr_fct::Ef,x1::Real,x2::Real, e::ErrorType; bounding = Best() ::BoundingType, ConcavityChanges = [Inf]::Array{Float64,1})\n\nMakes an optimal piecewise Linear approximation of expr_fct from x1 to x2. The result will be an array of LinearPiece. Note that the array is directly callable as a function.\n\nArguments\n\nexpr_fct : function to linearize (either an expresion or a native julia function)\nx1 : from\nx2 : to\ne : error type either Absolute() or Relative()\n\nOptional Arguments\n\nbounding : Under() for an underestimation, Over() for an overestimation, Best() for estimation that can go under or over the function. By default, it uses Best()\nConcavityChanges : Concavity changes in the function. If not given, they will be computed automatically which, in rare cases, can lead to precision errors if the concavity is asymptotic to zero. \n\nnote: Note\nIt is also possible to specify which algorithm to use between HeuristicLin() and ExactLin() by simply adding it after the error type. By default LinA uses the heuristic.\n\nExample\n\njulia> pwl = Linearize(:(x^2),0,2,Absolute(0.1))\n3-element Vector{LinA.LinearPiece}:\n 0.894427190999916 x -0.1 from 0.0 to 0.894427190999916\n 2.683281572999748 x -1.7000000000000006 from 0.894427190999916 to 1.7888543819998326\n 4.736067977499794 x -5.372135954999589 from 1.7888543819998326 to 2.0\n\njulia> pwl(1)\n0.9832815729997475\n\n\n\n\n\n","category":"function"},{"location":"","page":"LinA.jl Documentation","title":"LinA.jl Documentation","text":"LinearBounding","category":"page"},{"location":"#LinA.LinearBounding","page":"LinA.jl Documentation","title":"LinA.LinearBounding","text":"LinearBounding(expr_fct::Ef,x1::Real,x2::Real, e::ErrorType; ConcavityChanges = [Inf]::Array{Float64,1} )\n\nMakes an optimal piecewise Linear underestimation and overestimation of expr_fct from x1 to x2. For certain error types, it can saves a lot of overhead over calling Linearize two times.\n\nArguments\n\nexpr_fct : function to linearize (either an expresion or a native julia function)\nx1 : from\nx2 : to\ne : error type. Both Absolute() and Relative() are implemented.\n\nOptional Arguments\n\nConcavityChanges : Concavity changes in the function. If not given, they will be computed automatically which, in rare cases, can lead to precision errors if the concavity is asymptotic to zero. \n\n\n\n\n\n","category":"function"},{"location":"","page":"LinA.jl Documentation","title":"LinA.jl Documentation","text":"LinA.LinearizeConvex","category":"page"},{"location":"#LinA.LinearizeConvex","page":"LinA.jl Documentation","title":"LinA.LinearizeConvex","text":"LinearizeConvex(x1,x2,lower::Function,upper::Function,du::Function)\n\nMakes an optimal piecewise Linear approximation from x1 to x2 of a convex corridor\n\nArguments\n\nlower : function at the bottom of the corridor\nupper : function on top of the corridor\ndu : derivative of the upper function\n\n\n\n\n\n","category":"function"},{"location":"","page":"LinA.jl Documentation","title":"LinA.jl Documentation","text":"LinA.corridorFromInfo","category":"page"},{"location":"#LinA.corridorFromInfo","page":"LinA.jl Documentation","title":"LinA.corridorFromInfo","text":"corridorFromInfo(x1::Real,x2::Real,expr_fct::Ef,e::ErrorType,bounding::BoundingType)\n\nCreate a corridor from an error type and bounding style. This corridor is a tuple (start,end,lowerBound, upperbound, derivative of the upper bound)\n\nArguments\n\nx1 : from\nx2 : to\nexpr_fct : function to linearize (either an expresion or a native julia function)\ne : error type. Both Absolute() and Relative() are implemented\nbounding : Under() for an underestimation, Over() for an overestimation, Best() for estimation that can go under or over the function.\n\n\n\n\n\n","category":"function"},{"location":"","page":"LinA.jl Documentation","title":"LinA.jl Documentation","text":"LinA.exactPiece","category":"page"},{"location":"#LinA.exactPiece","page":"LinA.jl Documentation","title":"LinA.exactPiece","text":"exactPiece(start::Real,maximum::Real,lower,upper)\n\nComputes the maximal linear piece starting at start which lies in between lower and upper. Works for any continuous lower and upper.\n\nArguments\n\nstart : from\nmaximum : maximal end point of the linear segment\nlower : lower bound of the corridor\nupper : upper bound of the corridor\n\n\n\n\n\n","category":"function"}]
}
