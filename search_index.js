var documenterSearchIndex = {"docs":
[{"location":"#LinA.jl-Documentation","page":"LinA.jl Documentation","title":"LinA.jl Documentation","text":"","category":"section"},{"location":"","page":"LinA.jl Documentation","title":"LinA.jl Documentation","text":"Linearize","category":"page"},{"location":"#LinA.Linearize","page":"LinA.jl Documentation","title":"LinA.Linearize","text":"Linearize(expr_fct::Ef,x1::Real,x2::Real, e::ErrorType; bounding = Best() ::BoundingType, ConcavityChanges = [Inf]::Array{Float64,1})\n\nMakes an optimal piecewise Linear approximation of expr_fct from x1 to x2. The result will be an array of LinearPiece. Note that the array is directly callable as a function.\n\nArguments\n\nexpr_fct : function to linearize from R to R (either an expression or a native julia function)\nx1 : from\nx2 : to\ne : error type either Absolute() or Relative()\n\nOptional Arguments\n\nbounding : Under() for an underestimation, Over() for an overestimation, Best() for estimation that can go under or over the function. By default, it uses Best()\nConcavityChanges : Concavity changes in the function. If not given, they will be computed automatically which, in rare cases, can lead to precision errors if the concavity is asymptotic to zero. \n\nnote: Note\nIt is also possible to specify which algorithm to use between HeuristicLin() and ExactLin() by simply adding it after the error type. By default LinA uses the heuristic.\n\nnote: Note\nIf the function is given by a expression, the variable is assume to be x\n\nExample\n\njulia> pwl = Linearize(:(x^2),0,2,Absolute(0.1))\n3-element Vector{LinA.LinearPiece}:\n 0.894427190999916 x -0.1 from 0.0 to 0.894427190999916\n 2.683281572999748 x -1.7000000000000006 from 0.894427190999916 to 1.7888543819998326\n 4.736067977499794 x -5.372135954999589 from 1.7888543819998326 to 2.0\n\njulia> pwl(1)\n0.9832815729997475\n\n\n\n\n\n","category":"function"},{"location":"","page":"LinA.jl Documentation","title":"LinA.jl Documentation","text":"LinearBounding","category":"page"},{"location":"#LinA.LinearBounding","page":"LinA.jl Documentation","title":"LinA.LinearBounding","text":"LinearBounding(expr_fct::Ef,x1::Real,x2::Real, e::ErrorType; ConcavityChanges = [Inf]::Array{Float64,1} )\n\nMakes an optimal piecewise Linear underestimation and overestimation of expr_fct from x1 to x2. For certain error types, it can saves a lot of overhead over calling Linearize two times.\n\nArguments\n\nexpr_fct : function to linearize (either an expresion or a native julia function)\nx1 : from\nx2 : to\ne : error type. Both Absolute() and Relative() are implemented.\n\nOptional Arguments\n\nConcavityChanges : Concavity changes in the function. If not given, they will be computed automatically which, in rare cases, can lead to precision errors if the concavity is asymptotic to zero. \n\n\n\n\n\n","category":"function"},{"location":"","page":"LinA.jl Documentation","title":"LinA.jl Documentation","text":"LinA.LinearizeConvex","category":"page"},{"location":"#LinA.LinearizeConvex","page":"LinA.jl Documentation","title":"LinA.LinearizeConvex","text":"LinearizeConvex(x1,x2,lower::Function,upper::Function,du::Function)\n\nMakes an optimal piecewise Linear approximation from x1 to x2 of a convex corridor\n\nArguments\n\nlower : function at the bottom of the corridor\nupper : function on top of the corridor\ndu : derivative of the upper function\n\n\n\n\n\n","category":"function"},{"location":"","page":"LinA.jl Documentation","title":"LinA.jl Documentation","text":"LinA.CorridorFromInfo","category":"page"},{"location":"#LinA.CorridorFromInfo","page":"LinA.jl Documentation","title":"LinA.CorridorFromInfo","text":"CorridorFromInfo(x1::Real,x2::Real,expr_fct::Ef,e::ErrorType,bounding::BoundingType)\n\nCreate a corridor from an error type and bounding style. This corridor is a tuple (start,end,lowerBound, upperbound, derivative of the Upper bound)\n\nArguments\n\nx1 : from\nx2 : to\nexpr_fct : function to linearize (either an expresion or a native julia function)\ne : error type. Both Absolute() and Relative() are implemented\nbounding : Under() for an underestimation, Over() for an overestimation, Best() for estimation that can go under or over the function.\n\n\n\n\n\n","category":"function"},{"location":"","page":"LinA.jl Documentation","title":"LinA.jl Documentation","text":"LinA.ExactPiece","category":"page"},{"location":"#LinA.ExactPiece","page":"LinA.jl Documentation","title":"LinA.ExactPiece","text":"ExactPiece(start::Real,maximum::Real,lower,upper)\n\nComputes the maximal linear piece starting at start which lies in between lower and upper. Works for any continuous lower and upper.\n\nArguments\n\nstart : from\nmaximum : maximal end point of the linear segment\nlower : lower bound of the corridor\nupper : upper bound of the corridor\n\n\n\n\n\n","category":"function"},{"location":"","page":"LinA.jl Documentation","title":"LinA.jl Documentation","text":"LinA.Relative","category":"page"},{"location":"#LinA.Relative","page":"LinA.jl Documentation","title":"LinA.Relative","text":"Relative error from the function (in percentage)\n\n!!! warning\nFor a relative error to be well defined, the function needs to have no zeros!\n\n\n\n\n\n","category":"type"},{"location":"","page":"LinA.jl Documentation","title":"LinA.jl Documentation","text":"LinA.isContinuous","category":"page"},{"location":"#LinA.isContinuous","page":"LinA.jl Documentation","title":"LinA.isContinuous","text":"isContinuous(pwl, ε = 1e-5)\n\nDetermine whether a pwl function is continuous up to a numerical precision of ε.\n\nArguments\n\nplw : pwl function\nε : numerical precision\n\n\n\n\n\n","category":"function"},{"location":"","page":"LinA.jl Documentation","title":"LinA.jl Documentation","text":"LinA.CplexBreakpoints","category":"page"},{"location":"#LinA.CplexBreakpoints","page":"LinA.jl Documentation","title":"LinA.CplexBreakpoints","text":"CplexBreakpoints(pwl, ε = 1e-5)\n\nOutputs the breakpoints needed for CPLEX to natively model PWL functions.\n\nArguments\n\nplw : pwl function\nε : numerical precision\n\n\n\n\n\n","category":"function"}]
}
